نحوه عملکرد مرتب‌سازی انتخابی:
شروع از ابتدا: ابتدا، کوچک‌ترین عنصر را از کل لیست پیدا می‌کنیم.
جایگذاری عنصر کوچک‌تر: کوچک‌ترین عنصر پیدا شده را با اولین عنصر لیست عوض می‌کنیم.
تکرار برای باقی‌مانده لیست: برای باقی‌مانده لیست (از دومین عنصر به بعد) همین فرآیند را تکرار می‌کنیم تا همه عناصر مرتب شوند.



1. **ایده اصلی**:  
   در هر مرحله، کوچک‌ترین (یا بزرگ‌ترین) عنصر از بخش نامرتب آرایه پیدا می‌شود و به جایگاه صحیح خود در بخش مرتب آرایه منتقل می‌شود.

2. **تقسیم‌بندی آرایه**:  
   آرایه به دو بخش تقسیم می‌شود:  
   - **بخش مرتب‌شده**: عناصر از ابتدا که تا اینجا مرتب شده‌اند.  
   - **بخش نامرتب**: باقی‌مانده آرایه که هنوز بررسی نشده است.

3. **تعداد مقایسه‌ها**:  
   برای مرتب‌سازی یک آرایه با \(n\) عنصر:  
   - در اولین مرحله، \(n-1\) مقایسه انجام می‌شود.  
   - در مرحله دوم، \(n-2\) مقایسه انجام می‌شود.  
   - این روند ادامه دارد تا \(1\) مقایسه.  
   - در کل، تعداد مقایسه‌ها برابر است با:  
     \[
     \text{T}(n) = (n-1) + (n-2) + \dots + 1 = \frac{n(n-1)}{2}
     \]

4. **تعویض عناصر (Swap)**:  
   در هر مرحله، حداکثر یک بار تعویض انجام می‌شود، یعنی تعداد تعویض‌ها در بدترین حالت برابر با \(n-1\) است.

5. **پیچیدگی زمانی (Time Complexity)**:  
   - **حالت بد، متوسط و بهترین حالت**: \(O(n^2)\)  
     این الگوریتم همیشه دو حلقه تودرتو دارد که عناصر را مقایسه می‌کنند.

6. **پیچیدگی فضایی (Space Complexity)**:  
   - \(O(1)\)  
     نیازی به حافظه اضافی ندارد زیرا درجا (In-place) کار می‌کند.

7. **مناسب برای آرایه‌های کوچک**:  
   مرتب‌سازی انتخابی برای آرایه‌های کوچک مناسب است ولی برای آرایه‌های بزرگ به دلیل پیچیدگی زمانی \(O(n^2)\) کارایی کمی دارد.

8. **غیرپایدار بودن الگوریتم**:  
   این الگوریتم پایدار نیست، به این معنی که ترتیب عناصر هم‌ارزش در آرایه ممکن است تغییر کند.  

9. **سادگی پیاده‌سازی**:  
   مرتب‌سازی انتخابی از نظر فهم و پیاده‌سازی یکی از ساده‌ترین الگوریتم‌ها است.

10. **تعداد ثابت تبادل عناصر**:  
    تعداد تعویض‌ها در مقایسه با الگوریتم‌های دیگر مانند مرتب‌سازی حبابی کمتر است، ولی تعداد مقایسه‌ها بیشتر است.

---

اگر نکته‌ای نیاز به توضیح بیشتر دارد، بفرمایید!